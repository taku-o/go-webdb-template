# 設定ファイル分割・リファクタリング実装タスク一覧

## 概要
設定ファイル分割・リファクタリングの実装を段階的に進めるためのタスク一覧。要件定義書と設計書に基づき、実装可能な粒度でタスクを分解。

## 実装フェーズ

### Phase 1: ディレクトリ構造の作成

#### タスク 1.1: 環境別ディレクトリの作成
**目的**: 環境毎の設定ディレクトリを作成

**作業内容**:
- `config/develop/`ディレクトリを作成
- `config/production/`ディレクトリを作成
- `config/staging/`ディレクトリを作成

**受け入れ基準**:
- `config/develop/`ディレクトリが存在する
- `config/production/`ディレクトリが存在する
- `config/staging/`ディレクトリが存在する

---

### Phase 2: 設定ファイルの分割と移動

#### タスク 2.1: 開発環境設定ファイルの分割
**目的**: 開発環境の設定ファイルを分割し、新しいディレクトリに配置

**作業内容**:
- `config/develop.yaml`を読み込む
- `database`セクションを除いた内容で`config/develop/config.yaml`を作成
- `database`セクションの内容で`config/develop/database.yaml`を作成
- ファイル内容を確認して整合性をチェック

**受け入れ基準**:
- `config/develop/config.yaml`が存在し、`database`セクションを含まない
- `config/develop/database.yaml`が存在し、`database`セクションのみを含む
- 元の`config/develop.yaml`の内容が正しく分割されている

---

#### タスク 2.2: 本番環境設定ファイルの分割
**目的**: 本番環境の設定ファイルを分割し、新しいディレクトリに配置

**作業内容**:
- `config/production.yaml.example`を読み込む
- `database`セクションを除いた内容で`config/production/config.yaml.example`を作成
- `database`セクションの内容で`config/production/database.yaml.example`を作成
- ファイル内容を確認して整合性をチェック

**受け入れ基準**:
- `config/production/config.yaml.example`が存在し、`database`セクションを含まない
- `config/production/database.yaml.example`が存在し、`database`セクションのみを含む
- 元の`config/production.yaml.example`の内容が正しく分割されている

---

#### タスク 2.3: ステージング環境設定ファイルの分割
**目的**: ステージング環境の設定ファイルを分割し、新しいディレクトリに配置

**作業内容**:
- `config/staging.yaml`を読み込む
- `database`セクションを除いた内容で`config/staging/config.yaml`を作成
- `database`セクションの内容で`config/staging/database.yaml`を作成
- ファイル内容を確認して整合性をチェック

**受け入れ基準**:
- `config/staging/config.yaml`が存在し、`database`セクションを含まない
- `config/staging/database.yaml`が存在し、`database`セクションのみを含む
- 元の`config/staging.yaml`の内容が正しく分割されている

---

### Phase 3: 設定読み込みロジックの修正

#### タスク 3.1: Load()関数の修正（基本構造）
**目的**: 環境別ディレクトリから設定ファイルを読み込むように修正

**作業内容**:
- `server/internal/config/config.go`の`Load()`関数を開く
- 環境変数`APP_ENV`の取得ロジックは維持
- `viper.AddConfigPath()`の呼び出しを修正:
  - `../config/{env}/`を追加
  - `../../config/{env}/`を追加
  - `./config/{env}/`を追加
- 既存の`../config`, `../../config`, `./config`のパスは削除

**受け入れ基準**:
- `viper.AddConfigPath()`が環境別ディレクトリを指定している
- コンパイルエラーがない

---

#### タスク 3.2: Load()関数の修正（メイン設定ファイル読み込み）
**目的**: メイン設定ファイル（config.yaml）を読み込むように修正

**作業内容**:
- `viper.SetConfigName("config")`を追加（既存の`SetConfigName(env)`の前に実行）
- `viper.SetConfigType("yaml")`は維持
- `viper.ReadInConfig()`でメイン設定ファイルを読み込み
- エラーハンドリングを維持

**受け入れ基準**:
- メイン設定ファイル（`config/{env}/config.yaml`）が正しく読み込まれる
- エラーハンドリングが適切

---

#### タスク 3.3: Load()関数の修正（データベース設定ファイルマージ）
**目的**: データベース設定ファイル（database.yaml）をマージするように修正

**作業内容**:
- `viper.SetConfigName("database")`を追加
- `viper.MergeInConfig()`でデータベース設定ファイルをマージ
- エラーハンドリングを追加（ファイルが存在しない場合はエラーを返す）

**受け入れ基準**:
- データベース設定ファイル（`config/{env}/database.yaml`）が正しくマージされる
- エラーハンドリングが適切

---

#### タスク 3.4: Load()関数の修正（設定マッピングと環境変数処理）
**目的**: 統合された設定をConfig構造体にマッピングし、環境変数による上書きを維持

**作業内容**:
- `viper.Unmarshal(&cfg)`でConfig構造体にマッピング（既存ロジックを維持）
- 環境変数によるパスワード上書き処理（`DB_PASSWORD_SHARD*`）を維持
- 既存のエラーハンドリングを維持

**受け入れ基準**:
- Config構造体に正しくマッピングされる
- 環境変数によるパスワード上書きが正常に動作する
- 既存のエラーハンドリングが維持されている

---

### Phase 4: テスト

#### タスク 4.1: ユニットテストの作成
**目的**: Load()関数の動作を確認するユニットテストを作成

**作業内容**:
- `server/internal/config/config_test.go`を作成または更新
- テスト用の設定ファイルを`testdata/develop/`に配置:
  - `config.yaml`: テスト用メイン設定
  - `database.yaml`: テスト用データベース設定
- 以下のテストケースを実装:
  - 正常系: メイン設定ファイルとデータベース設定ファイルの両方が存在する場合
  - 正常系: 環境変数`APP_ENV`が設定されている場合
  - 正常系: 環境変数`APP_ENV`が設定されていない場合（デフォルト値の使用）
  - 正常系: 環境変数によるパスワード上書きが正常に動作する場合
  - 異常系: メイン設定ファイルが存在しない場合
  - 異常系: データベース設定ファイルが存在しない場合
  - 異常系: メイン設定ファイルのYAML構文が不正な場合
  - 異常系: データベース設定ファイルのYAML構文が不正な場合

**受け入れ基準**:
- すべてのテストケースが実装されている
- `go test`でテストが正常に実行できる
- すべてのテストがパスする

---

#### タスク 4.2: 既存テストの動作確認
**目的**: 既存のテストが正常に動作することを確認

**作業内容**:
- 既存のテストスイートを実行（`go test ./...`）
- テストが失敗する場合は原因を調査
- 必要に応じてテストを修正（設定ファイルのパス変更など）

**受け入れ基準**:
- 既存のテストがすべて正常に動作する
- テストの失敗がない

---

#### タスク 4.3: 手動動作確認
**目的**: 実際のアプリケーションで設定が正常に読み込まれることを確認

**作業内容**:
- 開発環境でアプリケーションを起動（`APP_ENV=develop`）
- 設定が正常に読み込まれていることを確認（ログ出力など）
- データベース接続が正常に動作することを確認
- ステージング環境でも同様に確認（`APP_ENV=staging`）

**受け入れ基準**:
- アプリケーションが正常に起動する
- 設定が正しく読み込まれている
- データベース接続が正常に動作する

---

### Phase 5: 既存ファイルの削除

#### タスク 5.1: 既存設定ファイルの削除
**目的**: 新しいディレクトリ構造に移行後、既存の設定ファイルを削除

**作業内容**:
- `config/develop.yaml`を削除
- `config/production.yaml.example`を削除
- `config/staging.yaml`を削除
- 削除前にバックアップを取る（必要に応じて）

**受け入れ基準**:
- 既存の設定ファイルが削除されている
- 新しいディレクトリ構造の設定ファイルのみが存在する

---

### Phase 6: ドキュメント更新

#### タスク 6.1: README.mdの更新
**目的**: 新しい設定ファイル構造をドキュメント化

**作業内容**:
- `README.md`を開く
- 設定ファイル構造の変更について説明を追加
- 新しいディレクトリ構造を説明
- 設定ファイルの読み込み順序を説明
- 必要に応じてセクションを追加

**受け入れ基準**:
- README.mdに新しい設定ファイル構造に関する説明が追加されている
- ディレクトリ構造が明確に記載されている
- 設定ファイルの読み込み順序が記載されている

---

#### タスク 6.2: .gitignoreの更新（オプション）
**目的**: データベース設定ファイルを除外するルールを追加（必要に応じて）

**作業内容**:
- `.gitignore`を開く
- 本番環境のデータベース設定ファイル（`config/production/database.yaml`）を除外するルールを追加（必要に応じて）
- ステージング環境のデータベース設定ファイル（`config/staging/database.yaml`）を除外するルールを追加（必要に応じて）

**受け入れ基準**:
- `.gitignore`に適切な除外ルールが追加されている（必要に応じて）

---

## タスク完了チェックリスト

### Phase 1: ディレクトリ構造の作成
- [ ] タスク 1.1: 環境別ディレクトリの作成

### Phase 2: 設定ファイルの分割と移動
- [ ] タスク 2.1: 開発環境設定ファイルの分割
- [ ] タスク 2.2: 本番環境設定ファイルの分割
- [ ] タスク 2.3: ステージング環境設定ファイルの分割

### Phase 3: 設定読み込みロジックの修正
- [ ] タスク 3.1: Load()関数の修正（基本構造）
- [ ] タスク 3.2: Load()関数の修正（メイン設定ファイル読み込み）
- [ ] タスク 3.3: Load()関数の修正（データベース設定ファイルマージ）
- [ ] タスク 3.4: Load()関数の修正（設定マッピングと環境変数処理）

### Phase 4: テスト
- [ ] タスク 4.1: ユニットテストの作成
- [ ] タスク 4.2: 既存テストの動作確認
- [ ] タスク 4.3: 手動動作確認

### Phase 5: 既存ファイルの削除
- [ ] タスク 5.1: 既存設定ファイルの削除

### Phase 6: ドキュメント更新
- [ ] タスク 6.1: README.mdの更新
- [ ] タスク 6.2: .gitignoreの更新（オプション）

## 注意事項

### 実装順序
- Phase 1 → Phase 2 → Phase 3 → Phase 4 → Phase 5 → Phase 6 の順序で実装する
- Phase 3の実装後、Phase 4でテストを実行して動作確認を行う
- Phase 5（既存ファイルの削除）は、Phase 4で動作確認が完了してから実行する

### 後方互換性
- 既存の`Config`構造体の定義は変更しない
- 既存の設定取得コード（`cfg.Database.Shards`など）はそのまま動作する
- 環境変数による上書き機能（`DB_PASSWORD_SHARD*`）は維持する

### エラーハンドリング
- メイン設定ファイルの読み込みエラーは既存と同様に処理
- データベース設定ファイルの読み込みエラーも適切に処理（必須とする）
- エラーメッセージは明確で分かりやすいものにする

### テスト
- 各フェーズの実装後、可能な限り早くテストを実行する
- 既存のテストが失敗する場合は、原因を調査して修正する
- 新しい機能に対するテストも追加する

### バージョン管理
- 既存の設定ファイルを削除する前に、変更履歴を確認できるようにする
- 必要に応じて、移行前の設定ファイルをバックアップする

