# 並列データベーステスト失敗対策の要件定義書

## 1. 概要

### 1.1 プロジェクト情報
- **プロジェクト名**: go-webdb-template
- **Issue番号**: #109
- **Issueタイトル**: 並列データベーステスト失敗対策
- **Feature名**: 0053-parallel-dbtest
- **作成日**: 2026-01-10

### 1.2 目的
並列実行されるデータベーステスト（`go test -parallel 4 ./test/integration/... ./test/e2e/..`）が失敗する問題を解決する。ロックファイルを使用した同時実行ブロック機構を実装し、データベースを扱うテストが安全に並列実行できるようにする。

### 1.3 スコープ
- ロックファイルを使用した同時実行ブロック機構の実装
- データベースを扱うテストでのロックファイル取得・解放処理の追加
- テスト終了時のロックファイル削除処理の実装

**本実装の範囲外**:
- テスト用データベースの分離（別の解決方法として検討可能だが、本実装では採用しない）
- 並列実行の完全な無効化（`-parallel 1`での実行は別の解決方法として検討可能だが、本実装では採用しない）

## 2. 背景・現状分析

### 2.1 現在の状況
- **テスト実行コマンド**: `go test -parallel 4 ./test/integration/... ./test/e2e/..`
- **テスト構造**: 
  - `test/integration/`: 統合テスト（9ファイル）
  - `test/e2e/`: E2Eテスト（3ファイル）
- **データベースセットアップ**: `testutil.SetupTestGroupManager()`を使用してPostgreSQLデータベースをセットアップ
- **問題**: 並列実行時にテストが失敗する

### 2.2 課題点
1. **データベース競合**: 複数のテストが同時に同じデータベースにアクセスし、競合が発生している
2. **スキーマ初期化の競合**: `SetupTestGroupManager()`内でスキーマを初期化する際に、並列実行で競合が発生している可能性
3. **データクリアの競合**: `ClearTestDatabase()`でデータをクリアする際に、並列実行で競合が発生している可能性
4. **テストの不安定性**: 並列実行時にテストが不安定になり、再現性のない失敗が発生している

### 2.3 本実装による改善点
1. **ロックファイルによる排他制御**: データベースを扱うテストがロックファイルを取得してから実行することで、同時実行を制御
2. **テストの安定性向上**: ロックファイルによる排他制御により、テストの安定性が向上
3. **並列実行の維持**: 並列実行の利点を維持しつつ、データベースアクセスの競合を防止

## 3. 機能要件

### 3.1 ロックファイル機構の実装

#### 3.1.1 ロックファイルの仕様
- **使用ライブラリ**: `gofrs/flock`（ファイルロックライブラリ）
- **ロックファイルの場所**: プロジェクトルート直下
  - プロジェクトルートは`server/go.mod`が存在するディレクトリ（`server/`ディレクトリ）を基準とする
  - 同一プロセス内の並列実行でも同じディレクトリを参照できることを保証
- **ロックファイル名**: `test-db.lock`（固定名）
- **ロックファイルの形式**: `gofrs/flock`が管理するロックファイル
- **Git管理**: ロックファイルは`.gitignore`に追加しない
  - `git status`でロックファイルの消し忘れに気づけるようにする
  - ロックファイルが残っている場合、`git status`で表示される

#### 3.1.2 ロック取得・解放の仕様
- **ロック取得**: データベースを扱うテストの開始時に`gofrs/flock`を使用してロックを取得
  - `flock.New(lockPath)`でロックオブジェクトを作成
  - `TryLockContext(ctx)`を使用してタイムアウト付きでロック取得（タイムアウト: 30秒）
  - ロック取得に失敗した場合（権限不足など）、エラーを返す
  - タイムアウトした場合、エラーを返す
- **ロック解放**: テスト終了時に`Unlock()`でロックを解放
  - `defer`を使用して確実に解放
  - テストが異常終了した場合でも、ロックが解放されるようにする（可能な限り）

#### 3.1.3 実装場所
- **新規作成**: `server/test/testutil/lock.go` - ロックファイル管理のユーティリティ関数
- **修正対象**: 
  - `server/test/testutil/db.go` - `SetupTestGroupManager()`にロック取得処理を追加
  - 各テストファイル - 必要に応じてロック取得・解放処理を追加（または`SetupTestGroupManager()`内で自動的に処理）

### 3.2 ロックファイル管理ユーティリティ

#### 3.2.1 関数仕様
- **`AcquireTestLock(t *testing.T) (*flock.Flock, error)`**: ロックファイルを取得し、`flock.Flock`オブジェクトを返す
  - プロジェクトルート直下の`test-db.lock`をロックファイルとして使用
  - `flock.New(lockPath)`でロックオブジェクトを作成
  - `context.WithTimeout(context.Background(), 30*time.Second)`でタイムアウト付きコンテキストを作成
  - `TryLockContext(ctx)`を使用してタイムアウト付きでロック取得（タイムアウト: 30秒）
  - ロック取得に成功したら、`flock.Flock`オブジェクトを返す
  - 呼び出し側で`defer fileLock.Unlock()`を実行してロックを解放
- **実装イメージ**:
  ```go
  // ロックファイルのパスを指定
  lockPath := filepath.Join(projectRoot, "test-db.lock")
  fileLock := flock.New(lockPath)
  
  // タイムアウト付きでロックを取得
  ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
  defer cancel()
  
  err := fileLock.TryLockContext(ctx)
  if err != nil {
      // ロック取得自体の失敗（権限不足など）またはタイムアウトのハンドリング
      // エラーメッセージにロックファイルのパスを含める
      if err == context.DeadlineExceeded {
          return nil, fmt.Errorf("%sのロックが取れなかったのでタイムアウトしました", lockPath)
      }
      return nil, fmt.Errorf("ロックファイルの取得に失敗しました (%s): %w", lockPath, err)
  }
  
  return fileLock, nil
  ```

#### 3.2.2 エラーハンドリング
- ロックファイルの作成に失敗した場合（権限不足など）、エラーを返す
  - エラーメッセージにロックファイルのパスを含める
- タイムアウトした場合（30秒以内にロック取得できない）、エラーを返す
  - エラーメッセージの形式: `"{ロックファイルPATH}のロックが取れなかったのでタイムアウトしました"`
  - ロックファイルの消し忘れに気づけるように、パスを明示的に表示
- ロックの解放に失敗した場合、警告をログに出力（テストは継続）

### 3.3 テストセットアップ関数の修正

#### 3.3.1 `SetupTestGroupManager()`の修正
- **変更内容**: 
  - 関数の開始時に`AcquireTestLock()`を呼び出してロックを取得
  - `defer fileLock.Unlock()`でロックを解放
  - ロック取得に失敗した場合（タイムアウト含む）、テストをスキップまたは失敗させる
- **実装イメージ**:
  ```go
  func SetupTestGroupManager(t *testing.T, dbCount int, tablesPerDB int) *db.GroupManager {
      // ロックを取得
      fileLock, err := AcquireTestLock(t)
      if err != nil {
          t.Fatalf("Failed to acquire test lock: %v", err)
      }
      defer fileLock.Unlock()
      
      // 既存の処理を続行
      // ...
  }
  ```

#### 3.3.2 既存テストへの影響
- **自動適用**: `SetupTestGroupManager()`を使用しているすべてのテストに自動的に適用される
- **追加修正不要**: 既存のテストコードを変更する必要はない（`SetupTestGroupManager()`内で処理）

### 3.4 代替案の検討

#### 3.4.1 検討した代替案
1. **ロックファイル方式（採用）**: ロックファイルを使用した同時実行ブロック
2. **並列実行の無効化**: `-parallel 1`で実行（採用しない）
3. **テスト用データベースの分離**: 各テストごとに別のデータベースを作成（採用しない）

#### 3.4.2 採用理由
- **ロックファイル方式**: 
  - 実装が比較的簡単
  - 既存のテストコードへの影響が最小限
  - 並列実行の利点を維持できる
- **他の方式を採用しない理由**:
  - 並列実行の無効化: テスト実行時間が長くなる
  - テスト用データベースの分離: 実装が複雑で、リソース消費が大きい

## 4. 非機能要件

### 4.1 パフォーマンス
- **ロック待機時間**: ロックファイルの待機時間を最小限に抑える（デフォルトタイムアウト: 30秒）
- **テスト実行時間**: ロックファイルによるオーバーヘッドを最小限に抑える
- **並列実行の維持**: 並列実行の利点を維持しつつ、データベースアクセスの競合を防止

### 4.2 信頼性
- **ロックファイルの確実な解放**: テストが異常終了した場合でも、ロックファイルが残らないようにする（可能な限り）
- **デッドロックの防止**: ロックファイルの待機時間にタイムアウトを設定し、デッドロックを防止
- **エラーハンドリング**: ロックファイルの取得・解放に失敗した場合の適切なエラーハンドリング

### 4.3 保守性
- **コードの可読性**: ロックファイル管理のコードを明確に分離
- **一貫性**: 既存のコードスタイルと一貫性を保つ
- **テスト容易性**: ロックファイル機構を独立してテスト可能

### 4.4 互換性
- **既存テスト**: 既存のテストが正常に動作することを確認
- **後方互換性**: 既存のテストコードを変更する必要はない（`SetupTestGroupManager()`内で処理）

## 5. 制約事項

### 5.1 技術的制約
- **Goのテストフレームワーク**: Go標準の`testing`パッケージを使用
- **ロックライブラリ**: `gofrs/flock`を使用（ファイルロックライブラリ）
- **ファイルシステム**: ロックファイルはファイルシステムに依存
- **並列実行**: Goの`-parallel`フラグによる並列実行に対応

### 5.2 実装上の制約
- **ロックファイルの場所**: プロジェクトルート直下（`server/go.mod`が存在するディレクトリ（`server/`ディレクトリ）を基準）
- **ロックファイル名**: `test-db.lock`（固定名）
- **ロックファイルの形式**: `gofrs/flock`が管理するロックファイル
- **タイムアウト**: ロックファイルの待機時間にタイムアウトを設定（デフォルト: 30秒）
- **プロセス間の一貫性**: 同一プロセス内の並列実行でも同じロックファイルを参照できることを保証

### 5.3 動作環境
- **ローカル環境**: ローカル環境で正常に動作することを確認
- **CI環境**: CI環境でも正常に動作することを確認（ファイルシステムへの書き込み権限が必要）

## 6. 受け入れ基準

### 6.1 ロックファイル機構の実装
- [ ] `gofrs/flock`ライブラリが`go.mod`に追加されている
- [ ] `server/test/testutil/lock.go`が作成されている
- [ ] `AcquireTestLock()`関数が実装されている（`gofrs/flock`を使用、タイムアウト30秒）
- [ ] ロックファイルの取得・解放が正常に動作する

### 6.2 `SetupTestGroupManager()`の修正
- [ ] `SetupTestGroupManager()`関数にロックファイル取得処理が追加されている
- [ ] `SetupTestGroupManager()`関数にロックファイル解放処理が追加されている（`defer`を使用）
- [ ] ロックファイルの取得に失敗した場合の適切なエラーハンドリングが実装されている

### 6.3 テストの動作確認
- [ ] `go test -parallel 4 ./test/integration/... ./test/e2e/..`が正常に実行できる
- [ ] 並列実行時にテストが失敗しない
- [ ] 既存のテストが全て失敗しないことを確認
- [ ] ロックファイルが適切に作成・削除されることを確認

### 6.4 エラーハンドリング
- [ ] ロックファイルの取得に失敗した場合の適切なエラーハンドリングが実装されている
- [ ] タイムアウトした場合の適切なエラーハンドリングが実装されている
  - [ ] エラーメッセージにロックファイルのパスが含まれている（形式: `"{ロックファイルPATH}のロックが取れなかったのでタイムアウトしました"`）
- [ ] ロックファイルの削除に失敗した場合の適切なエラーハンドリングが実装されている
- [ ] `.gitignore`にロックファイルが追加されていないことを確認

### 6.5 動作確認
- [ ] ローカル環境で`go test -parallel 4 ./test/integration/... ./test/e2e/..`が正常に実行できる
- [ ] CI環境で`go test -parallel 4 ./test/integration/... ./test/e2e/..`が正常に実行できる（該当する場合）
- [ ] ロックファイルが適切に作成・削除されることを確認
- [ ] 並列実行時にテストが安定して実行できることを確認

## 7. 影響範囲

### 7.1 変更が必要なファイル

#### 新規作成するファイル
- `server/test/testutil/lock.go`: ロックファイル管理のユーティリティ関数（`gofrs/flock`を使用）

#### 修正が必要なファイル
- `server/go.mod`: `gofrs/flock`ライブラリを追加
- `server/go.sum`: `gofrs/flock`ライブラリの依存関係を追加（`go mod tidy`で自動生成）
- `server/test/testutil/db.go`: `SetupTestGroupManager()`にロック取得処理を追加

#### 確認が必要なファイル
- 既存のテストファイル: 正常に動作することを確認（コード変更は不要）
- `.gitignore`: ロックファイル（`test-db.lock`）が`.gitignore`に追加されていないことを確認

### 7.2 既存機能への影響
- **すべてのデータベーステスト**: `SetupTestGroupManager()`を使用しているすべてのテストに自動的に適用される
- **既存のテスト**: 既存のテストコードを変更する必要はない（`SetupTestGroupManager()`内で処理）

### 7.3 将来の拡張への影響
- **パターンの確立**: ロックファイル機構の実装パターンが確立される
- **拡張性**: 将来的に他のリソース（Redis等）にも同様の機構を適用可能

## 8. 実装上の注意事項

### 8.1 ロックファイルの実装
- **使用ライブラリ**: `gofrs/flock`
- **ファイルの場所**: プロジェクトルート直下
  - `server/go.mod`が存在するディレクトリ（`server/`ディレクトリ）をプロジェクトルートとして判定
  - 同一プロセス内の並列実行でも同じディレクトリを参照できることを保証
- **ファイル名**: `test-db.lock`（固定名）
- **ロック取得方法**: 
  - `flock.New(lockPath)`でロックオブジェクトを作成
  - `TryLockContext(ctx)`を使用してタイムアウト付きでロック取得（タイムアウト: 30秒）
  - `context.WithTimeout(context.Background(), 30*time.Second)`でタイムアウト付きコンテキストを作成

### 8.2 ロック取得・解放の実装
- **ロック取得**: 
  - `flock.New(lockPath)`でロックオブジェクトを作成
  - `context.WithTimeout(context.Background(), 30*time.Second)`でタイムアウト付きコンテキストを作成
  - `TryLockContext(ctx)`を使用してタイムアウト付きでロック取得
  - ロック取得に失敗した場合（権限不足など）またはタイムアウトした場合、エラーを返す
  - エラーメッセージにロックファイルのパスを含める
    - タイムアウト時: `"{ロックファイルPATH}のロックが取れなかったのでタイムアウトしました"`
    - その他のエラー: `"ロックファイルの取得に失敗しました ({ロックファイルPATH}): {エラー詳細}"`
- **ロック解放**: `fileLock.Unlock()`でロックを解放
- **確実な解放**: `defer fileLock.Unlock()`を使用して確実にロックを解放

### 8.3 エラーハンドリング
- **ロック取得失敗**: ロックファイルの作成に失敗した場合、エラーを返す
  - エラーメッセージにロックファイルのパスを含める
- **タイムアウト**: ロックファイルの待機時間にタイムアウトを設定（デフォルト: 30秒）
  - エラーメッセージの形式: `"{ロックファイルPATH}のロックが取れなかったのでタイムアウトしました"`
  - ロックファイルの消し忘れに気づけるように、パスを明示的に表示
- **ロック解放失敗**: ロックファイルの削除に失敗した場合、警告をログに出力（テストは継続）

### 8.4 Git管理
- **`.gitignore`の設定**: ロックファイル（`test-db.lock`）は`.gitignore`に追加しない
  - `git status`でロックファイルの消し忘れに気づけるようにする
  - ロックファイルが残っている場合、`git status`で表示される
  - テスト実行後にロックファイルが残っている場合、手動で削除する必要があることを明示

### 8.5 テストの実装
- **単体テスト**: ロックファイル機構を独立してテスト可能
- **統合テスト**: 並列実行時の動作を確認するテストを追加（可能な限り）

## 9. 参考情報

### 9.1 関連Issue
- GitHub Issue #109: 並列データベーステスト失敗対策

### 9.2 既存実装の参考
- **テストユーティリティ**: `server/test/testutil/db.go`
- **テストファイル**: `server/test/integration/`, `server/test/e2e/`

### 9.3 技術スタック
- **言語**: Go
- **テストフレームワーク**: Go標準の`testing`パッケージ
- **ロックライブラリ**: `gofrs/flock`（ファイルロックライブラリ）
- **ファイルシステム**: `os`パッケージ、`path/filepath`パッケージ

### 9.4 関連ドキュメント
- `server/test/testutil/db.go`: 現在のテストデータベースセットアップの実装
- `server/test/integration/`: 統合テストの実装
- `server/test/e2e/`: E2Eテストの実装
